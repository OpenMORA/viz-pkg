#ifndef _INTERFAZSANCHO_PANELGRAF_H
#define _INTERFAZSANCHO_PANELGRAF_H

#include <wx/scrolwin.h>

#include <vector>
#include <string>
#include <sstream>

#include "Accion.h"
#include "Estado.h"
#include "Acciones.h"
#include "Dibujable.h"
#include "EstadoSimple.h"
#include "EstadoParalelo.h"
#include "EstadoCompuesto.h"

namespace InterfazSancho	{
class Main;
/**
  * This is the main class, although not the top-level one, of the GUI. It consists of a panel on which the states are drawn, moved or deleted by the user.
  * Unfortunately, it doesn't still allows to be managed with the keyboard, which forces the user to resort to the mouse. Most of the functionality can be achieved
  * by this class alone, although the internal state is currently changed externally. Now that the interface is not implemented on Flex but on an actual
  * programming language like C++, the user interface has access to right clicks, which may very easily allow the use of contextual menus to perform this kind of
  * actions without requiring another class.
  * This class' skeleton is partly generated by Codeblocks.
  * \bug For unknown reasons, the vertical scroll window never appears.
  * \sa Main, Main::cambiarEstado
  */
class PanelGraf:public wxScrolledWindow	{
public:
		PanelGraf(wxWindow *parent,Main *main,wxWindowID id);	//!< Constructor. Note that the parent does not have to be a Main object, although an object of that class must be provided.
		virtual ~PanelGraf()	{}	//!< Destructor.
		static void generarSCXMLSentencias(const std::vector<AccionPtr> &,std::ostringstream &);	//!< Given a list of actions, generates the SCXML code. May throw an exception if the variables are incorrectly defined.
		inline std::string generarSCXMLSentencias(const std::vector<AccionPtr> &accs)	{	//!< Wrapper to the homonym function.
			std::ostringstream oss("");
			generarSCXMLSentencias(accs,oss);
			return oss.str();
		}
		std::string generarSCXML(const std::string &initialStateName) const;	//!< Given the name of the initial state, generates the full SCXML code of the state machine.
		EstadoPtr getEstadoPorNombre(const std::string &) const;	//!< Given the name of a state, returns the smart pointer of the state, or NULL if no state has that name.
		virtual void OnDraw(wxDC &);
		void getTodosLosEventos(std::vector<wxString> &) const;	//!< Retrieves a full list of events, both custom and automatic.
		void getTodosLosEstados(std::vector<wxString> &) const;	//!< Retrieves a full list of state names.
		/**
		  * State of the interface. This controls how the GUI behaves when the mouse is clicked. -1 will move elements or call configuration dialogs; 0, 1 and 2 will
		  * respectively create simple, compound and parallel states; 3 will delete objects; and 4 will draw transition between two states.
		  */
		int estado;
		const static wxSize minSize;	//!< Minimal size of the panel.
		inline void anadirEstadoCompuesto(const EstadoCompuestoPtr &ec)	{	//!< Adds a compound state to this machine.
			EstadoPtr e=static_cast<EstadoPtr>(ec);
			estadosCompuestos.push_back(e);
			Estado::addState(e);	//This SHOULDN'T be necessary, although it's made for caution (if it's already present, the method won't do nothing).
			Refresh();
		}
		inline void anadirEstadoParalelo(const EstadoParaleloPtr &ep)	{	//!< Adds a parallel state to this machine.
			EstadoPtr e=static_cast<EstadoPtr>(ep);
			estadosCompuestos.push_back(e);
			Estado::addState(e);	//This SHOULDN'T be necessary, although it's made for caution (if it's already present, the method won't do nothing).
			Refresh();
		}
		inline void anadirEstadoSimple(const EstadoSimplePtr &es)	{	//!< Adds a simple state to this machine.
			estadosSimples.push_back(es);
			Estado::addState(static_cast<EstadoPtr>(es));	//This SHOULDN'T be necessary, although it's made for caution (if it's already present, the method won't do nothing).
			Refresh();
		}
		/**
		  * Code to execute when a parallel state is effectively to be created at certain point. The first parameter represents the number of substates, while the
		  * last one represents the hierarchy of objects inside which the state must be created (can be an empty hierarchy, which means that the creation will take
		  * place at top lavel).
		  */
		void eventoCreacionParalelo(size_t i,int px,int py,std::vector<DibujablePtr> &);
		inline Main *getPadre() const	{	//!< Returns the Main object thart contains this panel.
			return padre;
		}
		std::vector<DibujablePtr> getTodosLosObjetos(const wxPoint &p) const;	//!< Gets a comprehensive list of all the objects present in a point.
private:
		std::vector<EstadoSimplePtr> estadosSimples;	//!< List of simple states.
		std::vector<EstadoPtr> estadosCompuestos;	//!< List of non-simple (compound or parallel) states.
		DibujablePtr pulsando;	//!< Current object that is being selected.
		std::vector<DibujablePtr> jerPulsando;	//!< Current list of object lying under the selected one, precisely in the point from which it was selected.
		size_t contador;	//!< Counter for the successively created states, to get unique names.
		Main *padre;	//!< "Main" parent.
		wxPoint pulsadoP;	//!< Point from which the last selection was performed.

		DECLARE_EVENT_TABLE()

		void eventoBorrar(DibujablePtr &d);	//!< Signal an object to be actually deleted.
		void eventoMouseDown(wxMouseEvent &);
		void eventoMouseUp(wxMouseEvent &);
		/**
		  * Returns a list of pertinent objects to search for, given a point. The definition of what a pertinent object is depends on the state: for example, if the
		  * user wants to create a transition, which are created from states, the pertinent objects do not include already existing transitions.
		  */
		std::vector<DibujablePtr> getObjetos(int x,int y,int est) const;

		//Some functions must be templates because they're called both with a vector<EstadoPtr> and a vector<EstadoSimplePtr>.

		/**
		  * Adds a list of state names to an ordered list of strings.
		  */
		template<typename STATE_LIST> static void anadirEstados(const STATE_LIST &estados,std::vector<wxString> &cadenas)	{
			for (typename STATE_LIST::const_iterator it=estados.begin();it!=estados.end();++it)	{
				const EstadoPtr &o=*it;
				insertarCadenaOrdenada(_U(o->getNombre().c_str()),cadenas);
				std::vector<EstadoPtr> subestados;
				if (IS_DERIVED(o,EstadoCompuesto))	{
					(static_cast<const EstadoCompuestoPtr>(o))->getSubestados(subestados);
					anadirEstados(subestados,cadenas);
				}	else if (IS_DERIVED(o,EstadoParalelo))	{
					(static_cast<const EstadoParaleloPtr>(o))->getSubestados(subestados);
					anadirEstados(subestados,cadenas);
				}
			}
		}

		/**
		  * Given the name, searches for a state in a list. Returns EstadoPtr(NULL) if the search fails.
		  */
		template<typename STATE_LIST> static EstadoPtr buscarEstadoEnLista(const std::string &s,const STATE_LIST &l)	{
			for (typename STATE_LIST::const_iterator it=l.begin();it!=l.end();++it)	{
				const EstadoPtr &o=*it;
				if (o->getNombre()==s) return o;
				std::vector<EstadoPtr> subestados;
				if (IS_DERIVED(o,EstadoCompuesto))	{
					(static_cast<const EstadoCompuestoPtr>(o))->getSubestados(subestados);
					EstadoPtr res=buscarEstadoEnLista(s,subestados);
					if (res) return res;
				}	else if (IS_DERIVED(o,EstadoParalelo))	{
					(static_cast<const EstadoParaleloPtr>(o))->getSubestados(subestados);
					EstadoPtr res=buscarEstadoEnLista(s,subestados);
					if (res) return res;
				}
			}
			return EstadoPtr(NULL);
		}
		/**
		  * Inserts a string into an ordered list. This code is valid for both strings and wxStrings.
		  */
		template<typename STRING> static void insertarCadenaOrdenada(const STRING &s,std::vector<STRING> &l)	{
			if (find(l.begin(),l.end(),s)!=l.end()) return;
			for (typename std::vector<STRING>::iterator it=l.begin();it!=l.end();++it) if (!menorQue(*it,s))	{
				l.insert(it,s);
				return;
			}
			l.push_back(s);
		}
		/**
		  * Checks whether a string is lexically "smaller" (that is, previous) to another.
		  */
		template<typename STRING> static bool menorQue(const STRING &s1,const STRING &s2)	{
			size_t m=min(s1.length(),s2.length());
			for (size_t i=0;i<m;++i) if (s1[i]<s2[i]) return true;
			else if (s1[i]>s2[i]) return false;
			return s1.length()==m;
		}
		static std::string obtenerIDDeSentencia(const AccionPtr &ac);	//!< Given an action, returns its identifier (which only makes sense if it's a robot action).
};
}	//End of namespace
#endif
